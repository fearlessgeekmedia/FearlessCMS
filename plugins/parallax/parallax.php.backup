<?php
error_log("PARALLAX PLUGIN FILE LOADED!");
// Parallax Sections Plugin v2.0
// Adds parallax scrolling effects for website sections using shortcodes

// Register the plugin hooks
fcms_add_hook('init', 'parallax_init');
fcms_add_hook("content", "parallax_process_shortcode");

// Initialize the plugin
function parallax_init() {
    if (getenv('FCMS_DEBUG') === 'true') {
        error_log("Parallax plugin v2.0 initialized");
    }
}

// Process parallax shortcodes in content
function parallax_process_shortcode($content) {
    if (getenv('FCMS_DEBUG') === 'true') {
        error_log("Parallax plugin processing content length: " . strlen($content));
    }
    
    // Check if content contains parallax shortcodes
    if (strpos($content, '[parallax_section') === false) {
        return $content; // No parallax shortcodes, return content as-is
    }
    
    // Process parallax shortcodes
    $content = preg_replace_callback('/\[parallax_section(.*?)\](.*?)\[\/parallax_section\]/s', 'process_parallax_shortcode', $content);
    
    // Add CSS and JavaScript to the content
    $content .= get_parallax_assets();
    
    if (getenv('FCMS_DEBUG') === 'true') {
        error_log("Parallax processing complete. Content length after: " . strlen($content));
    }
    
    return $content;
}

// Process a single parallax shortcode
function process_parallax_shortcode($matches) {
    $attributes_text = $matches[1];
    $inner_content = $matches[2];
    
    if (getenv('FCMS_DEBUG') === 'true') {
        error_log("Processing parallax shortcode - Attributes: " . $attributes_text . ", Content length: " . strlen($inner_content));
    }
    
    // Default values
    $id = '';
    $background_image = '';
    $speed = '0.5';
    $effect = 'scroll';
    $overlay_color = 'rgba(0,0,0,0.4)';
    $overlay_opacity = '0.4';
    $css_class = '';
    $custom_id = '';
    
    // Extract attributes using regex
    if (preg_match('/id="([^"]+)"/', $attributes_text, $id_match)) {
        $id = $id_match[1];
    }
    if (preg_match('/background_image="([^"]+)"/', $attributes_text, $bg_match)) {
        $background_image = $bg_match[1];
    }
    if (preg_match('/speed="([^"]+)"/', $attributes_text, $speed_match)) {
        $speed = $speed_match[1];
    }
    if (preg_match('/effect="([^"]+)"/', $attributes_text, $effect_match)) {
        $effect = $effect_match[1];
    }
    if (preg_match('/overlay_color="([^"]+)"/', $attributes_text, $color_match)) {
        $overlay_color = $color_match[1];
    }
    if (preg_match('/overlay_opacity="([^"]+)"/', $attributes_text, $opacity_match)) {
        $overlay_opacity = $opacity_match[1];
    }
    if (preg_match('/class="([^"]+)"/', $attributes_text, $class_match)) {
        $css_class = $class_match[1];
    }
    if (preg_match('/custom_id="([^"]+)"/', $attributes_text, $custom_id_match)) {
        $custom_id = $custom_id_match[1];
    }
    
    if (getenv('FCMS_DEBUG') === 'true') {
        error_log("Parsed attributes - ID: $id, Background: $background_image, Speed: $speed, Effect: $effect, Overlay: $overlay_color, Opacity: $overlay_opacity, Class: $css_class, Custom ID: $custom_id");
    }
    
    // Validate required attributes
    if (empty($id) || empty($background_image)) {
        return '<div class="alert alert-danger">Parallax section requires both id and background_image attributes</div>';
    }
    
    // Generate unique CSS class
    $default_css_class = 'parallax-section-' . sanitize_id($id);
    $final_css_class = trim($default_css_class . ' ' . $css_class);
    
    // Clean up the inner content
    $inner_content = clean_parallax_content($inner_content);
    
    // Build the parallax section HTML
    $output = '<div id="' . htmlspecialchars($id) . '" class="' . $final_css_class . ' parallax-section" data-speed="' . htmlspecialchars($speed) . '" data-effect="' . htmlspecialchars($effect) . '" data-overlay-color="' . htmlspecialchars($overlay_color) . '" data-overlay-opacity="' . htmlspecialchars($overlay_opacity) . '"';
    
    // Add custom ID if specified
    if (!empty($custom_id)) {
        $output .= ' data-custom-id="' . htmlspecialchars($custom_id) . '"';
    }
    
    $output .= '>';
    $output .= '<div class="parallax-background" style="background-image: url(\'' . htmlspecialchars($background_image) . '\');"></div>';
    $output .= '<div class="parallax-content">';
    $output .= $inner_content;
    $output .= '</div>';
    $output .= '</div>';
    
    if (getenv('FCMS_DEBUG') === 'true') {
        error_log("Generated parallax HTML: " . substr($output, 0, 200) . "...");
    }
    
    return $output;
}

// Clean up parallax content
function clean_parallax_content($content) {
    // Remove paragraph tags that are just wrapping the shortcode content
    $content = preg_replace('/<p>\s*\[parallax_section/', '[parallax_section', $content);
    $content = preg_replace('/\[\/parallax_section\]\s*<\/p>/', '[/parallax_section]', $content);
    
    // Remove empty paragraphs
    $content = preg_replace('/<p>\s*<\/p>/', '', $content);
    
    // Clean up any remaining paragraph wrapping issues
    $content = preg_replace('/<p>\s*<div/', '<div', $content);
    $content = preg_replace('/<\/div>\s*<\/p>/', '</div>', $content);
    
    // Remove paragraph tags that are purely wrapping other HTML elements
    $content = preg_replace('/<p>\s*(<(?!\/?p\b)[^>]*>.*?<\/[^>]*>)\s*<\/p>/s', '$1', $content);
    
    // Remove paragraph tags that are just wrapping text (but preserve the text)
    $content = preg_replace('/<p>\s*([^<]+)\s*<\/p>/s', '$1', $content);
    
    return $content;
}

// Sanitize ID for CSS class
function sanitize_id($id) {
    return preg_replace('/[^a-zA-Z0-9_-]/', '', $id);
}

// Get CSS and JavaScript as a string
function get_parallax_assets() {
    return <<<'ASSETS'
<!-- Parallax Plugin v2.0 - Enhanced Coverage & Performance -->
<style>
    .parallax-section {
        position: relative !important;
        overflow: hidden !important;
        max-width: 100vw !important;
        width: 100% !important;
        
        margin: 0 !important;
        padding: 0 !important;
        display: block !important;
        min-height: 500px !important;
        height: auto !important;
        background: transparent !important;
    }
    
    .parallax-background {
        position: absolute !important;
        top: 0px !important;
        left: 0 !important;
        width: 100% !important;
        
        height: 175% !important;
        top: -45% !important;
        background-size: cover !important;
        background-attachment: fixed !important;
        background-position: center center !important;
        background-repeat: no-repeat !important;
        background-attachment: scroll !important;
        z-index: 1 !important;
        will-change: transform;
        background-clip: border-box;
        transform: translateZ(0);
    }
    
    .parallax-content {
        position: relative !important;
        z-index: 3 !important;
        padding: 2rem 1rem !important;
        min-height: 400px !important;
        display: flex !important;
        flex-direction: column !important;
        justify-content: center !important;
        align-items: center !important;
        text-align: center !important;
        width: 100% !important;
        
        height: 175% !important;
        top: -45% !important;
        box-sizing: border-box !important;
    }
    
    /* Ensure content is readable over background */
    .parallax-content h1,
    .parallax-content h2,
    .parallax-content h3,
    .parallax-content h4,
    .parallax-content h5,
    .parallax-content h6 {
        text-shadow: 3px 3px 6px rgba(0,0,0,0.9);
        color: white !important;
    }
    
    .parallax-content p {
        text-shadow: 2px 2px 4px rgba(0,0,0,0.9);
        color: white !important;
    }
    
    .parallax-content a {
        text-shadow: 2px 2px 4px rgba(0,0,0,0.9);
        color: white !important;
    }
    
    .parallax-content span,
    .parallax-content strong,
    .parallax-content em,
    .parallax-content code,
    .parallax-content mark {
        text-shadow: 2px 2px 4px rgba(0,0,0,0.9);
        color: white !important;
    }
    
    /* Responsive adjustments */
    @media (max-width: 768px) {
        .parallax-section {
            min-height: 400px;
        }
        
        .parallax-content {
            padding: 2rem 1rem;
            min-height: 300px;
        }
    }
    
    /* Button styling for parallax sections */
    .parallax-content .btn-primary,
    .parallax-content .btn-secondary {
        background: rgba(255,255,255,0.9);
        color: #333 !important;
        text-shadow: none;
        padding: 0.75rem 1.5rem;
        border-radius: 0.5rem;
        text-decoration: none;
        display: inline-block;
        margin: 0.5rem;
        transition: all 0.3s ease;
    }
    
    .parallax-content .btn-primary:hover,
    .parallax-content .btn-secondary:hover {
        background: rgba(255,255,255,1);
        transform: translateY(-2px);
        box-shadow: 0 4px 8px rgba(0,0,0,0.3);
    }
    
    .parallax-overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 2;
    }
</style>

<script>
    // Parallax scrolling effect
    function initParallax() {
        const parallaxSections = document.querySelectorAll('.parallax-section');
        
        if (parallaxSections.length === 0) return;
        
        // Set up scroll event listener
        window.addEventListener('scroll', function() {
            parallaxSections.forEach(function(section) {
                const speed = parseFloat(section.dataset.speed) || 0.5;
                const effect = section.dataset.effect || 'scroll';
                const background = section.querySelector('.parallax-background');
                
                if (!background) return;
                
                if (effect === 'scroll') {
                    const scrolled = window.pageYOffset;
                    const rate = scrolled * speed;
                    const finalRate = rate * 0.3;
                    background.style.transform = "translateY(" + finalRate + "px) translateZ(0)";
                } else if (effect === 'fixed') {
                    background.style.transform = 'translateY(0) translateZ(0)';
                    background.style.position = 'fixed';
                } else if (effect === 'scale') {
                    const rect = section.getBoundingClientRect();
                    const scrolled = window.pageYOffset;
                    const sectionTop = rect.top + scrolled;
                    const rate = (scrolled - sectionTop) * speed;
                    const scale = 1 + (rate * 0.001);
                    background.style.transform = "scale(" + Math.max(0.5, Math.min(2.0, scale)) + ") translateZ(0)";
                } else if (effect === 'rotate') {
                    const rect = section.getBoundingClientRect();
                    const scrolled = window.pageYOffset;
                    const sectionTop = rect.top + scrolled;
                    const rate = (scrolled - sectionTop) * speed;
                    const rotation = rate * 0.1;
                    background.style.transform = "rotate(" + rotation + "deg) translateZ(0)";
                } else if (effect === 'fade') {
                    const rect = section.getBoundingClientRect();
                    const scrolled = window.pageYOffset;
                    const sectionTop = rect.top + scrolled;
                    const rate = (scrolled - sectionTop) * speed;
                    const opacity = Math.max(0.1, Math.min(1.0, 1 - (Math.abs(rate) * 0.001)));
                    background.style.opacity = opacity;
                } else if (effect === 'fade-in') {
                    // Fade-in effect: content gradually appears as you scroll down
                    const rect = section.getBoundingClientRect();
                    const scrolled = window.pageYOffset;
                    const sectionTop = rect.top + scrolled;
                    const rate = (scrolled - sectionTop) * speed;
                    
                    // Get configurable parameters from data attributes
                    const fadeStartPercent = parseFloat(section.dataset.fadeStartPercent) || 25; // Default: start when 25% into viewport
                    const fadeDistance = parseFloat(section.dataset.fadeDistance) || 50; // Default: fade over 50% of viewport
                    const startOpacity = parseFloat(section.dataset.startOpacity) || 0.1; // Default: start at 10% opacity
                    const startOffset = parseFloat(section.dataset.startOffset) || 20; // Default: start 20px down
                    
                    // Only start fade-in when section is partially visible (viewport is over the area)
                    const viewportHeight = window.innerHeight;
                    const sectionVisible = viewportHeight - rect.top;
                    const fadeStartThreshold = viewportHeight * (fadeStartPercent / 100);
                    
                    if (sectionVisible > fadeStartThreshold) {
                        // Calculate fade-in progress based on how much of the section is visible
                        const fadeProgress = Math.min(1.0, (sectionVisible - fadeStartThreshold) / (viewportHeight * (fadeDistance / 100)));
                        const opacity = Math.max(startOpacity, Math.min(1.0, startOpacity + (fadeProgress * (1.0 - startOpacity))));
                        const content = section.querySelector('.parallax-content');
                        if (content) {
                            content.style.opacity = opacity;
                            content.style.transform = `translateY(${Math.max(0, startOffset - (opacity * startOffset))}px)`;
                        }
                    } else {
                        // Keep content hidden until fade-in threshold is met
                        const content = section.querySelector('.parallax-content');
                        if (content) {
                            content.style.opacity = startOpacity;
                            content.style.transform = "translateY(" + startOffset + "px)";
                        }
                    }
                    } else {
                        // Keep content hidden until fade-in threshold is met
                        const content = section.querySelector('.parallax-content');
                        if (content) {
                            content.style.opacity = 0.1;
                            content.style.transform = `translateY(20px)`;
                        }
                    }
                } else if (effect === 'fade') {
                    // Fade effect: background opacity changes during scroll
                    const rect = section.getBoundingClientRect();
                    const scrolled = window.pageYOffset;
                    const sectionTop = rect.top + scrolled;
                    const rate = (scrolled - sectionTop) * speed;
                    const opacity = Math.max(0.1, Math.min(1.0, 1 - (Math.abs(rate) * 0.001)));
                    background.style.opacity = opacity;
                } else if (effect === 'rotate') {
                    // Rotation effect: background rotates during scroll
                    const rect = section.getBoundingClientRect();
                    const scrolled = window.pageYOffset;
                    const sectionTop = rect.top + scrolled;
                    const rate = (scrolled - sectionTop) * speed;
                    const rotation = rate * 0.1; // Rotation in degrees
                    background.style.transform = "rotate(" + rotation + "deg) translateZ(0)";
                } else if (effect === 'scale') {
                    // Scale effect: background scales up/down during scroll
                    const rect = section.getBoundingClientRect();
                    const scrolled = window.pageYOffset;
                    const sectionTop = rect.top + scrolled;
                    const rate = (scrolled - sectionTop) * speed;
                    const scale = 1 + (rate * 0.001); // Scale factor
                    background.style.transform = "scale(" + Math.max(0.5, Math.min(2.0, scale)) + ") translateZ(0)";
                } else if (effect === 'blur') {
                    const rect = section.getBoundingClientRect();
                    const scrolled = window.pageYOffset;
                    const sectionTop = rect.top + scrolled;
                    const rate = (scrolled - sectionTop) * speed;
                    const blur = Math.max(0, Math.min(8, Math.abs(rate) * 0.005));
                    background.style.filter = "blur(" + blur + "px)";
                } else if (effect === 'slide') {
                    const rect = section.getBoundingClientRect();
                    const scrolled = window.pageYOffset;
                    const sectionTop = rect.top + scrolled;
                    const rate = (scrolled - sectionTop) * speed;
                    const slideRate = rate * 0.5;
                    background.style.transform = "translateX(" + slideRate + "px) translateZ(0)";
                } else if (effect === 'zoom') {
                    const rect = section.getBoundingClientRect();
                    const scrolled = window.pageYOffset;
                    const sectionTop = rect.top + scrolled;
                    const rate = (scrolled - sectionTop) * speed;
                    const zoom = 1 + (rate * 0.0005);
                    background.style.transform = "scale(" + Math.max(0.3, Math.min(3.0, zoom)) + ") translateZ(0)";
                }
            });
        });
        
        // Initialize overlay styles
        setOverlayStyles();
    }
    
    // Set overlay styles for parallax sections
    function setOverlayStyles() {
        const parallaxSections = document.querySelectorAll('.parallax-section');
        
        parallaxSections.forEach(function(section) {
            const overlayColor = section.dataset.overlayColor || 'rgba(0,0,0,0.4)';
            const overlayOpacity = section.dataset.overlayOpacity || '0.4';
            
            let finalColor = overlayColor;
            if (overlayColor.startsWith("rgba")) {
                finalColor = overlayColor;
            } else if (overlayColor.startsWith("#")) {
                finalColor = hexToRgba(overlayColor, overlayOpacity);
            } else {
                finalColor = colorNameToRgba(overlayColor, overlayOpacity);
            }
            
            // Apply the overlay color
            const overlayDiv = document.createElement("div");
            overlayDiv.className = "parallax-overlay";
            overlayDiv.style.cssText = "position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: " + finalColor + "; z-index: 2;";
            
            // Remove existing overlay if any
            const existingOverlay = section.querySelector(".parallax-overlay");
            if (existingOverlay) {
                existingOverlay.remove();
            }
            
            // Insert the overlay before the content
            const content = section.querySelector(".parallax-content");
            if (content) {
                section.insertBefore(overlayDiv, content);
            }
        });
    }
    
    // Helper function to convert hex to rgba
    function hexToRgba(hex, opacity) {
        const r = parseInt(hex.slice(1, 3), 16);
        const g = parseInt(hex.slice(3, 5), 16);
        const b = parseInt(hex.slice(5, 7), 16);
        return "rgba(" + r + "," + g + "," + b + "," + opacity + ")";
    }
    
    // Helper function to convert color names to rgba
    function colorNameToRgba(colorName, opacity) {
        const colors = {
            "black": "0,0,0",
            "white": "255,255,255",
            "red": "255,0,0",
            "green": "0,128,0",
            "blue": "0,0,255",
            "yellow": "255,255,0",
            "purple": "128,0,128",
            "orange": "255,165,0",
            "pink": "255,192,203",
            "brown": "165,42,42",
            "gray": "128,128,128",
            "grey": "128,128,128"
        };
        
        const rgb = colors[colorName.toLowerCase()] || "0,0,0";
        return "rgba(" + rgb + "," + opacity + ")";
    }
    
    // Initialize parallax when DOM is ready
    if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", initParallax);
    } else {
        initParallax();
    }
    
    // Also initialize on window load for images
    window.addEventListener("load", function() {
        // Ensure all background images are loaded
        const parallaxSections = document.querySelectorAll(".parallax-section");
        parallaxSections.forEach(function(section) {
            const background = section.querySelector(".parallax-background");
            if (background) {
                const bgImage = background.style.backgroundImage;
                if (bgImage && bgImage !== "none") {
                    const imgUrl = bgImage.replace(/url\(["\'\]?([^"\'\]+)["\'\]?)\)/, "$1");
                    const img = new Image();
                    img.onload = function() {
                        background.classList.add("loaded");
                    };
                    img.onerror = function() {
                        console.warn("Failed to load parallax background image:", imgUrl);
                    };
                    img.src = imgUrl;
                } else {
                    background.classList.add("loaded");
                }
            }
        });
        
        // Initialize overlays after images are loaded
        setOverlayStyles();
    });
</script>
ASSETS;
}
?>
