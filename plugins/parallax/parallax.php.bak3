<?php
// Parallax Sections Plugin
// Adds parallax scrolling effects for website sections using shortcodes

// Register the plugin
fcms_add_hook('init', 'parallax_init');
fcms_add_hook('content', 'parallax_process_shortcode');

// Initialize the plugin
function parallax_init() {
    // Add CSS and JavaScript to the page
    parallax_enqueue_assets();
}

// Process parallax shortcodes
function parallax_process_shortcode($content) {
    // Helper function to process a single shortcode match
    $process_match = function($matches) {
        $attributes = $matches[1];
        $inner_content = $matches[2];
        
        // Default values
        $id = '';
        $background_image = '';
        $speed = '0.5';
        $effect = 'scroll';
        $overlay_color = 'rgba(0,0,0,0.4)'; // Default dark overlay
        $overlay_opacity = '0.4'; // Default opacity
        
        // Extract attributes using regex
        if (preg_match('/id="([^"]+)"/', $attributes, $id_match)) {
            $id = $id_match[1];
        }
        if (preg_match('/background_image="([^"]+)"/', $attributes, $bg_match)) {
            $background_image = $bg_match[1];
        }
        if (preg_match('/speed="([^"]+)"/', $attributes, $speed_match)) {
            $speed = $speed_match[1];
        }
        if (preg_match('/effect="([^"]+)"/', $attributes, $effect_match)) {
            $effect = $effect_match[1];
        }
        if (preg_match('/overlay_color="([^"]+)"/', $attributes, $color_match)) {
            $overlay_color = $color_match[1];
        }
        if (preg_match('/overlay_opacity="([^"]+)"/', $attributes, $opacity_match)) {
            $overlay_opacity = $opacity_match[1];
        }
        
        if (getenv('FCMS_DEBUG') === 'true') {
            error_log("Parsed attributes - ID: $id, Background: $background_image, Speed: $speed, Effect: $effect, Overlay: $overlay_color, Opacity: $overlay_opacity");
        }
        
        // Validate required attributes
        if (empty($id) || empty($background_image)) {
            return '<div class="alert alert-danger">Parallax section requires both id and background_image attributes</div>';
        }
        
        // Generate unique CSS class
        $css_class = 'parallax-section-' . sanitize_id($id);
        
        // Clean up the inner content by removing unwanted paragraph wrappers and fixing HTML structure
        // Only remove empty paragraphs and fix div wrapping issues, preserve actual content
        $inner_content = preg_replace('/<p>\s*<div/', '<div', $inner_content);
        $inner_content = preg_replace('/<\/div>\s*<\/p>/', '</div>', $inner_content);
        $inner_content = preg_replace('/<p>\s*<\/p>/', '', $inner_content);
        
        // Only remove paragraph tags that are purely wrapping other HTML elements
        // This preserves span tags and other inline HTML
        $inner_content = preg_replace('/<p>\s*(<(?!\/?p\b)[^>]*>.*?<\/[^>]*>)\s*<\/p>/s', '$1', $inner_content);
        
        // Remove paragraph tags that are just wrapping text (but preserve the text)
        $inner_content = preg_replace('/<p>\s*([^<]+)\s*<\/p>/s', '$1', $inner_content);
        
        // Build the parallax section HTML
        $output = '<div id="' . htmlspecialchars($id) . '" class="' . $css_class . ' parallax-section" data-speed="' . htmlspecialchars($speed) . '" data-effect="' . htmlspecialchars($effect) . '" data-overlay-color="' . htmlspecialchars($overlay_color) . '" data-overlay-opacity="' . htmlspecialchars($overlay_opacity) . '">';
        $output .= '<div class="parallax-background" style="background-image: url(\'' . htmlspecialchars($background_image) . '\');"></div>';
        $output .= '<div class="parallax-content">';
        $output .= $inner_content;
        $output .= '</div>';
        $output .= '</div>';
        
        if (getenv('FCMS_DEBUG') === 'true') {
            error_log("Generated parallax HTML: " . substr($output, 0, 200) . "...");
        }
        
        return $output;
    };
    
    // Use a regex that handles both escaped and unescaped underscores
    // The pattern matches [parallax_section...] and [/parallax_section] with optional backslashes
    $content = preg_replace_callback('/\[parallax_section(.*?)\](.*?)\[\/parallax_section\]/s', $process_match, $content);
    
    // Also handle escaped underscores that the markdown parser creates
    $content = preg_replace_callback('/\[parallax_section(.*?)\](.*?)\[\/parallax_section\]/s', $process_match, $content);
    
    return $content;
}

// Sanitize ID for CSS class
function sanitize_id($id) {
    return preg_replace('/[^a-zA-Z0-9_-]/', '', $id);
}

// Add CSS and JavaScript to the page
function parallax_enqueue_assets() {
    // Add CSS
    echo '<style>
        .parallax-section {
            position: relative;
            overflow: hidden;
            min-height: 500px;
            width: 100%;
            margin: 0;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .parallax-background {
            position: absolute;
            top: -20%;
            left: 0;
            width: 100%;
            height: 140%;
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            z-index: 1;
        }
        
        .parallax-content {
            position: relative;
            z-index: 3;
            padding: 4rem 2rem;
            min-height: 400px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
        }
        
        /* Ensure content is readable over background */
        .parallax-content h1,
        .parallax-content h2,
        .parallax-content h3,
        .parallax-content h4,
        .parallax-content h5,
        .parallax-content h6 {
            text-shadow: 3px 3px 6px rgba(0,0,0,0.9);
            color: white !important;
        }
        
        .parallax-content p {
            text-shadow: 2px 2px 4px rgba(0,0,0,0.9);
            color: white !important;
        }
        
        .parallax-content a {
            text-shadow: 2px 2px 4px rgba(0,0,0,0.9);
            color: white !important;
        }
        
        /* Support for inline HTML elements like span, strong, em, etc. */
        .parallax-content span,
        .parallax-content strong,
        .parallax-content em,
        .parallax-content b,
        .parallax-content i,
        .parallax-content code,
        .parallax-content mark {
            text-shadow: 2px 2px 4px rgba(0,0,0,0.9);
            color: inherit;
        }
        
        /* Dynamic overlay for better text readability */
        .parallax-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        
        /* Ensure background images are always visible */
        .parallax-background {
            will-change: transform;
            transform: translateZ(0);
        }
    </style>';
    
    // Add JavaScript
    echo '<script>
        function initParallax() {
            const parallaxSections = document.querySelectorAll(".parallax-section");
            
            if (parallaxSections.length === 0) {
                console.log("No parallax sections found");
                return;
            }
            
            console.log("Found " + parallaxSections.length + " parallax sections");
            
            // Set up scroll event listener for parallax effect
            window.addEventListener("scroll", function() {
                parallaxSections.forEach(function(section) {
                    const rect = section.getBoundingClientRect();
                    const speed = parseFloat(section.dataset.speed) || 0.5;
                    const effect = section.dataset.effect || "scroll";
                    
                    // Only apply parallax when section is in view
                    if (rect.top < window.innerHeight && rect.bottom > 0) {
                        const background = section.querySelector(".parallax-background");
                        if (background) {
                            const scrolled = window.pageYOffset;
                            const rate = scrolled * -speed * 0.3; // Reduced speed for subtle effect
                            background.style.transform = "translateY(" + rate + "px)";
                        }
                    }
                });
            });
            
            // Initialize overlays
            setOverlayStyles();
        }
        
        // Function to set overlay colors and opacity
        function setOverlayStyles() {
            console.log("Setting overlay styles...");
            const parallaxSections = document.querySelectorAll(".parallax-section");
            console.log("Found " + parallaxSections.length + " parallax sections");
            
            parallaxSections.forEach(function(section, index) {
                const overlayColor = section.dataset.overlayColor || "rgba(0,0,0,0.4)";
                const overlayOpacity = section.dataset.overlayOpacity || "0.4";
                
                console.log("Section " + index + " - Color: " + overlayColor + ", Opacity: " + overlayOpacity);
                
                // Convert color names to hex if needed
                let finalColor = overlayColor;
                if (overlayColor.startsWith("rgba")) {
                    // If it is already rgba, just use it
                    finalColor = overlayColor;
                } else if (overlayColor.startsWith("#")) {
                    // If it is hex, convert to rgba with opacity
                    finalColor = hexToRgba(overlayColor, overlayOpacity);
                } else {
                    // If it is a color name, convert to rgba
                    finalColor = colorNameToRgba(overlayColor, overlayOpacity);
                }
                
                console.log("Final color: " + finalColor);
                
                // Apply the overlay color directly to the ::before pseudo-element
                // Since we can not directly style pseudo-elements, we will add an inline style
                const overlayDiv = document.createElement("div");
                overlayDiv.className = "parallax-overlay";
                overlayDiv.style.cssText = "position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: " + finalColor + "; z-index: 1;";
                
                // Remove existing overlay if any
                const existingOverlay = section.querySelector(".parallax-overlay");
                if (existingOverlay) {
                    existingOverlay.remove();
                }
                
                // Insert the overlay before the content
                const content = section.querySelector(".parallax-content");
                if (content) {
                    section.insertBefore(overlayDiv, content);
                    console.log("Overlay added to section " + index);
                } else {
                    console.log("No content found in section " + index);
                }
            });
        }
        
        // Helper function to convert hex to rgba
        function hexToRgba(hex, opacity) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return "rgba(" + r + "," + g + "," + b + "," + opacity + ")";
        }
        
        // Helper function to convert color names to rgba
        function colorNameToRgba(colorName, opacity) {
            const colors = {
                "black": "0,0,0",
                "white": "255,255,255",
                "red": "255,0,0",
                "green": "0,128,0",
                "blue": "0,0,255",
                "yellow": "255,255,0",
                "purple": "128,0,128",
                "orange": "255,165,0",
                "pink": "255,192,203",
                "brown": "165,42,42",
                "gray": "128,128,128",
                "grey": "128,128,128"
            };
            
            const rgb = colors[colorName.toLowerCase()] || "0,0,0";
            return "rgba(" + rgb + "," + opacity + ")";
        }
        
        // Initialize parallax when DOM is ready
        if (document.readyState === "loading") {
            document.addEventListener("DOMContentLoaded", initParallax);
        } else {
            initParallax();
        }
        
        // Also initialize on window load for images
        window.addEventListener("load", initParallax);
        
        // Initialize overlays when parallax is ready
        document.addEventListener("DOMContentLoaded", setOverlayStyles);
        window.addEventListener("load", setOverlayStyles);
    </script>';
}
?> 